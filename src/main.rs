#![warn(rust_2018_idioms)]
#![warn(rust_2021_compatibility)]

use clap::{Parser, Subcommand};

use git_testament::{git_testament, render_testament};
use ngs::{derive, generate, index, list, plot, qc};

#[derive(Parser)]
#[command(author, version = render_testament!(TESTAMENT), propagate_version = true, about, long_about = None)]
struct Cli {
    #[command(subcommand)]
    pub subcommand: Subcommands,

    /// Only errors are printed to the stderr stream.
    #[arg(short, long)]
    pub quiet: bool,

    /// All available information, including debug information, is printed to stderr.
    #[arg(short, long)]
    pub verbose: bool,
}

#[derive(Subcommand)]
enum Subcommands {
    /// Forensic analysis tool for next-generation sequencing data.
    Derive(derive::command::DeriveArgs),

    /// Generates a BAM file from a given reference genome.
    Generate(generate::command::GenerateArgs),

    /// Generates the index file to various next-generation sequencing files.
    Index(index::command::IndexArgs),

    /// Utility to list various supported items in this command line tool.
    List(list::command::ListArgs),

    /// Produces plots for data generated by `ngs qc`.
    Plot(plot::command::PlotArgs),

    /// Generates quality control metrics for BAM files.
    Qc(qc::command::QcArgs),
}

git_testament!(TESTAMENT);

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();

    //===========//
    // Verbosity //
    //===========//

    let level = if cli.verbose {
        tracing::Level::DEBUG
    } else if cli.quiet {
        tracing::Level::ERROR
    } else {
        tracing::Level::INFO
    };

    let subscriber = tracing_subscriber::fmt::Subscriber::builder()
        .with_max_level(level)
        .with_writer(std::io::stderr)
        .finish();
    tracing::subscriber::set_global_default(subscriber)?;

    //=====================//
    // Subcommand matching //
    //=====================//

    match cli.subcommand {
        Subcommands::Derive(args) => match args.subcommand {
            derive::command::DeriveSubcommand::Instrument(args) => {
                derive::command::instrument::derive(args)?
            }
        },
        Subcommands::Generate(args) => generate::command::generate(args)?,
        Subcommands::Index(args) => index::command::index(args)?,
        Subcommands::List(args) => list::command::list(args)?,
        Subcommands::Plot(args) => match args.subcommand {
            plot::command::PlotSubcommand::Cohort(args) => plot::cohort::plot(args)?,
            plot::command::PlotSubcommand::Sample(args) => plot::sample::plot(args)?,
        },
        Subcommands::Qc(args) => qc::command::qc(args)?,
    };

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn verify_cli() {
        use clap::CommandFactory;
        Cli::command().debug_assert()
    }
}
